<?php
/**
 * This is an example implementation of the SimpleAPI class,
 *   to build your own API
 * This is not your API endpoint: your API endpoint or endpoints will include this class
 *   and probably instruct this class to behave as the endpoint expects the API to behave
 * Change this in your own project to fine tune the SimpleAPI for your own implementation
 * The SimpleAPI does not implement on it's own any features for translation,
 *   these should be taken care of by your own API implementation here
 * The SimpleAPI is transparent when it comes to accepted parameters:
 *   your API implementation should define the accepted parameters,
 *   we have included an APIParams class to assist with this
 * The Github Repo user and name are useful for things like ICAL output...
 *   You may not therefore need these, but you may find it useful for other purposes.
*/

//TODO: see if it's possible to move the cache definitions to the SimpleAPI class
ini_set('display_errors', 1);
ini_set('display_startup_errors', 1);
error_reporting(E_ALL);

include_once( 'includes/SimpleAPI.php' );
include_once( 'includes/enums/CacheDuration.php' );
include_once( "includes/APIParams.php" );

class SampleAPI {
    const API_VERSION                               = '0.1';
    public SimpleAPI $SimpleAPI;
    private APIParams $APIParams;
    private string   $CacheDuration                 = "";
    private string   $CACHEFILE                     = "";
    private string   $CACHEPATH                     = "";
    //define the following array if you find a use for it
    private array    $GithubRepo                    = [ "User" => "", "Name" => "" ];
    private array    $AllowedResponseTypes;
    private string   $XMLParentElement              = "";
    private string   $XMLNamespace                  = "";

    private array $responseData                     = [];

    public function __construct(){
        $this->SimpleAPI                              = new SimpleAPI();
        $this->CacheDuration                        = "_" . CacheDuration::MONTH . date( "m" );
        //define your own cachepath here, it will be relative to the path of the SampleAPI script...
        $this->CACHEPATH                            = "engineCache";    //change this to the path where you woud like to store your API's cache files!
        //uncomment these and set them accordingly if you have use for checking against the latest release,
        //for example when generating an ICAL response...
        $this->GithubRepo["User"]                   = "JohnRDOrazio";   //change this to your repo user!
        $this->GithubRepo["Name"]                   = "SampleAPI";      //change this to your repo name!
        $this->XMLParentElement                       = "SampleAPI";      //this will be the main parent of your XML output, if you allow an XML resource to be requested
        //the following address doesn't have to be resolveable, it's not a URL
        //it's a URN and only needs to identify the XML resource as being generated by your API
        $this->XMLNamespace                           = "https://myapidomain.com/{$this->GithubRepo["Name"]}"; //you don't have to use the repo name, you can use any name you wish
    }

    private static function convertArray2XML(array $data, ?SimpleXMLElement &$xml) : void {
        foreach( $data as $key => $value ) {
            if( is_array( $value ) ) {
                $new_object = $xml->addChild( $key );
                self::convertArray2XML( $value, $new_object );
            } else {
                // if the key is a number, it needs text with it to actually work
                if( is_numeric( $key ) ) {
                    $key = "numeric_$key";
                }
                $xml->addChild( $key, $value );
            }
        }
    }

    private function initParameterData() {
        if ( $this->SimpleAPI->getRequestContentType() === RequestContentType::JSON ) {
            $json = file_get_contents( 'php://input' );
            $data = json_decode( $json, true );
            if( NULL === $json || "" === $json ){
                header( $_SERVER[ "SERVER_PROTOCOL" ]." 400 Bad Request", true, 400 );
                die( '{"error":"No JSON data received in the request: <' . $json . '>"' );
            } else if ( json_last_error() !== JSON_ERROR_NONE ) {
                header( $_SERVER[ "SERVER_PROTOCOL" ]." 400 Bad Request", true, 400 );
                die( '{"error":"Malformed JSON data received in the request: <' . $json . '>, ' . json_last_error_msg() . '"}' );
            } else {
                $this->APIParams = new APIParams( $data );
            }
        } else {
            switch( $this->SimpleAPI->getRequestMethod() ) {
                case RequestMethod::POST:
                    $this->APIParams = new APIParams( $_POST );
                    break;
                case RequestMethod::GET:
                    $this->APIParams = new APIParams( $_GET );
                    break;
                case RequestMethod::OPTIONS:
                    //continue
                    break;
                default:
                    header( $_SERVER[ "SERVER_PROTOCOL" ]." 405 Method Not Allowed", true, 405 );
                    $errorMessage = '{"error":"You seem to be forming a strange kind of request? Allowed Request Methods are ';
                    $errorMessage .= implode( ' and ', $this->SimpleAPI->getAllowedRequestMethods() );
                    $errorMessage .= ', but your Request Method was ' . $this->SimpleAPI->getRequestMethod() . '"}';
                    die( $errorMessage );
            }
        }
        if( $this->APIParams->ResponseType !== null ) {
            if( in_array( $this->APIParams->ResponseType, $this->AllowedResponseTypes ) ) {
                $this->SimpleAPI->setResponseContentType( $this->SimpleAPI->getAllowedAcceptHeaders()[ array_search( $this->APIParams->ResponseType, $this->AllowedResponseTypes ) ] );
            } else {
                header( $_SERVER[ "SERVER_PROTOCOL" ]." 406 Not Acceptable", true, 406 );
                $errorMessage = '{"error":"You are requesting a content type which this API cannot produce. Allowed content types are ';
                $errorMessage .= implode( ' and ', $this->AllowedResponseTypes );
                $errorMessage .= ', but you have issued a parameter requesting a Content Type of ' . strtoupper( $this->APIParams->ResponseType ) . '"}';
                die( $errorMessage );
            }
        } else {
            if( $this->SimpleAPI->hasAcceptHeader() ) {
                if( $this->SimpleAPI->isAllowedAcceptHeader() ) {
                    $this->APIParams->ResponseType = $this->AllowedResponseTypes[ $this->SimpleAPI->getIdxAcceptHeaderInAllowed() ];
                    $this->SimpleAPI->setResponseContentType( $this->SimpleAPI->getAcceptHeader() );
                } else {
                    //Requests from browser windows using the address bar will probably have an Accept header of text/html
                    //In order to not be too drastic, let's treat text/html as though it were application/json
                    $acceptHeaders = explode( ",", $this->SimpleAPI->getAcceptHeader() );
                    if( in_array( 'text/html', $acceptHeaders ) || in_array( 'text/plain', $acceptHeaders ) || in_array( '*/*', $acceptHeaders ) ) {
                        $this->APIParams->ResponseType = ResponseType::JSON;
                        $this->SimpleAPI->setResponseContentType( AcceptHeader::JSON );
                    } else {
                        header( $_SERVER[ "SERVER_PROTOCOL" ]." 406 Not Acceptable", true, 406 );
                        $errorMessage = '{"error":"You are requesting a content type which this API cannot produce. Allowed Accept headers are ';
                        $errorMessage .= implode( ' and ', $this->SimpleAPI->getAllowedAcceptHeaders() );
                        $errorMessage .= ', but you have issued an request with an Accept header of ' . $this->SimpleAPI->getAcceptHeader() . '"}';
                        die( $errorMessage );
                    }

                }
            } else {
                $this->APIParams->ResponseType = $this->AllowedResponseTypes[ 0 ];
                $this->SimpleAPI->setResponseContentType( $this->SimpleAPI->getAllowedAcceptHeaders()[ 0 ] );
            }
        }
    }

    /**
     * 
    */
    private function cacheFileIsAvailable() : bool {
        $cacheFilePath = "{$this->CACHEPATH}/v" . str_replace( ".", "_", self::API_VERSION ) . "/";
        $cacheFileName = md5( serialize( $this->APIParams) ) . $this->CacheDuration . "." . strtolower( $this->APIParams->ResponseType );
        $this->CACHEFILE = $cacheFilePath . $cacheFileName;
        return file_exists( $this->CACHEFILE );
    }

    //Uncomment the following method if you have a use for checking against the latest release...
    /*private function getGithubReleaseInfo() : stdClass {
        [ "User" => $repoUser, "Name" => $repoName ] = $this->GithubRepo;
        $returnObj = new stdClass();
        $GithubReleasesAPI = "https://api.github.com/repos/{$repoUser}/{$repoName}/releases/latest";
        $ch = curl_init();
        curl_setopt( $ch, CURLOPT_URL, $GithubReleasesAPI );
        curl_setopt( $ch, CURLOPT_USERAGENT, 'LiturgicalCalendar' );
        curl_setopt( $ch, CURLOPT_RETURNTRANSFER, true );
        $currentVersionForDownload = curl_exec( $ch );

        if ( curl_errno( $ch ) ) {
          $returnObj->status = "error";
          $returnObj->message = curl_error( $ch );
        }
        curl_close( $ch );

        $GitHubReleasesObj = json_decode( $currentVersionForDownload );
        if( json_last_error() !== JSON_ERROR_NONE ){
            $returnObj->status = "error";
            $returnObj->message = json_last_error_msg();
        } else {
            $returnObj->status = "success";
            $returnObj->obj = $GitHubReleasesObj;
        }
        return $returnObj;
    }
    */

    private function generateResponse() : string {
        $Response                          = new stdClass();
        //elaborate your Response further here!
        //This object will be transformed into the JSON or XML or ICS response, or whatever response type was requested
        //You can define methods within the class to assist in calculating or retrieving the data for the Response
        $Response->APIParams               = new stdClass();
        foreach( $this->APIParams as $key => $value ) {
            $Response->APIParams->{$key} = $value;
        }

        $Response->Data = $this->responseData;

        //we make sure we have a Cache folder for the current Version, if we have enabled cached responses
        if( realpath( "{$this->CACHEPATH}/v" . str_replace( ".", "_", self::API_VERSION ) ) === false ) {
            mkdir( "{$this->CACHEPATH}/v" . str_replace( ".", "_", self::API_VERSION ), 0755, true );
        }

        //here you may define your own cases to handle each response type supported by your API
        switch ( $this->APIParams->ResponseType ) {
            case ResponseType::JSON:
                //if a JSON resource was requested, we transform our response to JSON
                $response = json_encode( $Response );
                break;
            case ResponseType::XML:
                //if an XML resource was requested, we transform our response to XML
                $jsonStr = json_encode( $Response );
                $jsonObj = json_decode( $jsonStr, true );
                $xml = new SimpleXMLElement ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?" . "><{$this->XMLParentElement} xmlns=\"{$this->XMLNamespace}\"/>" );
                self::convertArray2XML( $jsonObj, $xml );
                $response = $xml->asXML();
                break;
            /*case ResponseType::ICS:
                $infoObj = $this->getGithubReleaseInfo();
                if( $infoObj->status === "success" ) {
                    $response = $this->produceIcal( $Response, $infoObj->obj );
                }
                else{
                    die( '{"Error": "Error receiving or parsing info from github about latest release: '.$infoObj->message . '"}' );
                }
                break;
            */
            default:
                $response = json_encode( $Response );
                break;
        }
        file_put_contents( $this->CACHEFILE, $response );
        return $response;
    }

    private static function outputEtagHeaderOrResponse( string $responseContents ) {
        $responseHash = md5( $responseContents );
        header("Etag: \"{$responseHash}\"");
        if (!empty( $_SERVER['HTTP_IF_NONE_MATCH'] ) && $_SERVER['HTTP_IF_NONE_MATCH'] === $responseHash) {
            header( $_SERVER[ "SERVER_PROTOCOL" ] . " 304 Not Modified" );
            header('Content-Length: 0');
        } else {
            echo $responseContents;
        }
        die();
    }

    public function setCacheDuration( string $duration ) : void {
        switch( $duration ) {
            case CacheDuration::MINUTE:
                $this->CacheDuration = "_" . $duration . date( "i" ); //The minute of the current hour of the current day of the request
                break;
            case CacheDuration::HOUR:
                $this->CacheDuration = "_" . $duration . date( "G" ); //The hour of the current day of the request
                break;
            case CacheDuration::DAY:
                $this->CacheDuration = "_" . $duration . date( "z" ); //The day of the year of the request ( starting from 0 through 365 )
                break;
            case CacheDuration::WEEK:
                $this->CacheDuration = "_" . $duration . date( "W" ); //ISO-8601 week number of year (weeks starting on Monday) of the request
                break;
            case CacheDuration::MONTH:
                $this->CacheDuration = "_" . $duration . date( "m" ); //Numeric representation of the month (with leading zeros) of the request
                break;
            case CacheDuration::YEAR:
                $this->CacheDuration = "_" . $duration . date( "Y" ); //A full numeric representation of the year (4 digits) of the request
                break;
        }
    }

    public function setAllowedResponseTypes( array $responseTypes ) : void {
        $this->AllowedResponseTypes = array_values( array_intersect( ResponseType::$values, $responseTypes ) );
    }

    /**
     * Your SampleAPI will only work once you call the public Init() method
     */
    public function Init(){
        $this->SimpleAPI->Init();
        $this->initParameterData();
        //you may have your own methods to load and calculate data here,
        //perhaps automating settings based on parameters, etc.

        //once you have taken care of getting parameters and calculations done,
        //we can set our response header
        $this->SimpleAPI->setResponseContentTypeHeader();

        if( $this->cacheFileIsAvailable() ){
            //If we already have done the calculation
            //and stored the results in a cache file
            //then we're done, just output this and die
            //or better, make the client use it's own cache copy!
            $responseContents = file_get_contents( $this->CACHEFILE );
        } else {
            //do your API stuff here, any calculations to prepare your response
            for( $i = 0; $i < $this->APIParams->Param2; $i++ ) {
                $this->responseData[] = $this->APIParams->Param1;
            }
            //once your response is ready, we can now send it
            $responseContents = $this->generateResponse();
        }
        $this->outputEtagHeaderOrResponse( $responseContents );
    }

}
